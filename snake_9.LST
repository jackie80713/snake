C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 1   


C51 COMPILER V8.18, COMPILATION OF MODULE SNAKE_9
OBJECT MODULE PLACED IN snake_9.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE snake_9.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          2017.07.02
   3          final !!
   4          Can control up & down & left & right! Add random (OK) !
   5          Add food & eaten food!(OK)
   6          Add random start seat!(OK)
   7          Add speed!(OK)
   8          ç¢ºèªé ­éƒ¨å’Œé£Ÿç‰©éƒ½æ²’å•é¡Œ!
   9          å•é¡Œ : å°¾å·´é¡¯ç¤ºå’Œç§»å‹•çš„å•é¡Œ! (OK)
  10          use 89s51 will happen error : data memory too large! (OK)
  11          grade bug !(OK)
  12          body bug....(body 1 2 OK)
  13          win & lost(OK)
  14          improve the button sensitivity!
  15          author:lypon
  16          */
  17          #include<AT89X52.H>
  18          #include<stdlib.h>
  19          #include<INTRINS.H>
  20          
  21          /////////// function /////////////////
  22          
  23          int random(int *seed);                            // å–äº‚æ•¸
  24          void initial(unsigned char matrix[]);             // é‡æ–°åˆå§‹åŒ–é™£åˆ—
  25          void direction(int *Direction);                   // æ–¹å‘
  26          void move(int *Head_start_num,int *Direction);// ç§»å‹•
  27          void food(void);                                                          // ç”¢ç”Ÿé£Ÿç‰©
  28          void food_check(int *Head_start_num);             // ç¢ºèªé£Ÿç‰©æ˜¯å¦é‡ç–Šåˆ°é ­éƒ¨
  29          void match(void);                             // æŠŠè¦é¡¯ç¤ºçš„é™£åˆ—éƒ½åˆèµ·ä¾†
  30          void scan(unsigned char k);                       // æƒæé¡¯ç¤º
  31          void delayms(unsigned int time);                  // å»¶é²æ™‚é–“
  32          
  33          void Direction_matrix_right(void);
  34          void tail_move(void);
  35          
  36          ///////////////////////////////////////
  37          
  38          /////////// display matrix/////////////
  39          
  40          unsigned char start_seat[] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
  41          unsigned char head_show[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  42          unsigned char food_show[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  43          unsigned char body_display[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  44          unsigned char display[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  45          unsigned char win[] = {0x3c,0x42,0x95,0xa1,0xa1,0x95,0x42,0x3c};
  46          unsigned char defeat[] = {0x3c,0x42,0xa5,0x91,0x91,0xa5,0x42,0x3c};
  47          unsigned char go[] = {0x7e,0x81,0x71,0xf6,0x7e,0x81,0x81,0x7e};
  48          unsigned char idata tail[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  49          unsigned char idata tail_temp[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};      // å°¾å·´ç§»å‹•å‰ä½ç½®
  50          unsigned char idata head_show_temp[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // é ­ç§»å‹•å‰ä½ç½®
  51          char idata Direction_matrix[64] = {0};
  52          
  53          ///////////////////////////////////////
  54          
  55          //////////// global variable //////////
C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 2   

  56          
  57          int set_win_grade = 63;                  // å‹åˆ©åˆ†æ•¸
  58          bit lost = 0;                           // å¤±æ•—é–‹é—œ
  59          bit eaten = 0;                                                  // é€²é£Ÿé–‹é—œ
  60          int seed = 3;                           // äº‚æ•¸ç¨®å­
  61          int grade = 0;                                              // åˆ†æ•¸
  62          int grade_temp;                                                 // åˆ†æ•¸æ¯”è¼ƒ
  63          char food_start = 0x00;                                 // é£Ÿç‰©åˆå§‹ä½ç½®
  64          int food_num = 0;                                               // é£Ÿç‰©åˆå§‹ä½ç½®
  65          
  66          
  67          int Direction_num = 1;                  // å°¾å·´è¦ç§»å‹•æ–¹å‘çš„ä½ç½®
  68          int tail_start_num = 0;                                 // å°¾å·´é–‹å§‹ä½ç½®           
  69          int tail_start_num_temp = 0;                    // å°¾å·´ç§»å‹•å‰ä½ç½®æ•¸å­—
  70          int head_start_num_temp = 0;                    // é ­ç§»å‹•å‰ä½ç½®æ•¸å­—
  71          int speed = 45;                                                 // é€Ÿåº¦
  72          bit start = 0;
  73          ///////////////////////////////////////
  74          
  75          main()
  76          {
  77   1              int Head_start_num = random(&seed)%8; // need find turly random way ! decide start row
  78   1              int Direction_key = 1; //default direction down
  79   1              int i;
  80   1              unsigned char x=0;
  81   1              unsigned char t;
  82   1              
  83   1              P3 = 0x00;                            // P3 ä¸æ¸…æ¥šç‚ºä»€éº¼ä¸èƒ½æ”¾åœ¨å‰é¢è¨­å®š?
  84   1              
  85   1              ///////////////////// éš¨æ©Ÿæ±ºå®šèµ·å§‹ä½ç½® //////////////////////
  86   1              
  87   1              while(P3 != 0x80)
  88   1              {
  89   2                      for(t=0;t<15;t++)  // speed
  90   2                      {
  91   3                              scan(x);
  92   3                      }
  93   2                      seed++;
  94   2              }
  95   1                      seed++;
  96   1              
  97   1              Head_start_num = random(&seed)%8;
  98   1              
  99   1              head_show[Head_start_num] = start_seat[Head_start_num];
 100   1              
 101   1              /////////////////////////////////////////////////////////////
 102   1              food();
 103   1              
 104   1              while(1)
 105   1              {
 106   2                      start = 1;
 107   2                      initial(display);
 108   2                      
 109   2                      if(grade == 0)                                  // ç•¶é‚„æ²’æœ‰èº«é«”çš„æ™‚å€™ï¼Œè¦ä¸æ–·åœ°è¨˜éŒ„å°¾å·´çš„ä½ç½®(é 
             -­ç§»å‹•å‰çš„ä½ç½®ç­‰æ–¼å°¾å·´çš„ä½ç½®)
 110   2                      {
 111   3                              tail[Head_start_num] = head_show[Head_start_num];
 112   3                              tail_start_num = Head_start_num;
 113   3                      }
 114   2                              
 115   2                      
 116   2                      if(seed > 20000)
C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 3   

 117   2                              seed = 1;
 118   2      
 119   2                      food_check(&Head_start_num);
 120   2                      
 121   2                      if (grade_temp == grade)  // å¦‚æœ grade_temp ç­‰æ–¼ grade å°±ä»£è¡¨ç¾åœ¨æ²’æœ‰å†é€²é£Ÿå¯ä»¥é€²è¡Œæœ
             -‰æ²’æœ‰å’¬åˆ°èº«é«”çš„åˆ¤æ–·!!
 122   2                              eaten = 0;
 123   2                      
 124   2                      if(grade >= 1)                                                     // ç•¶åˆ†æ•¸å¤§æ–¼1ä¹Ÿå°±æ˜¯èº«é«”é•·åº¦å¤§æ–¼1çš„æ™‚å€™ï¼Œé–‹å§‹
             -è¨˜éŒ„é ­ç§»å‹•å‰çš„ä½ç½®ï¼Œ
 125   2                      {                                                                                                  // å› ç‚ºç§»å‹•å‰çš„é ­ä½ç½®å’Œå°¾å·´çš„ä½ç½®å·²ç¶“ä¸ä¸€æ¨£äº†!!
 126   3                              head_show_temp[Head_start_num] = head_show[Head_start_num];
 127   3                              head_start_num_temp = Head_start_num;
 128   3                      }
 129   2                      
 130   2                      grade_temp = grade;       // ç‚ºäº†ä¿å­˜é€™æ¬¡çš„ grade_temp æ‰€ä»¥é¸æ“‡åœ¨åˆ¤æ–·å®Œ grade_temp å’Œ gr
             -adeæ˜¯å¦ç›¸ç­‰å¾Œå†åˆ·æ–°!!
 131   2                      
 132   2                      move(&Head_start_num,&Direction_key); // snack moving
 133   2              
 134   2                      Direction_matrix[0] = Direction_key;  // è¨˜éŒ„æ¯ä¸€æ¬¡é ­ç§»å‹•çš„æ–¹å‘
 135   2                      Direction_matrix_right();                         // æ¯ç§»å‹•ä¸€æ¬¡å°±æŠŠæ–¹å‘é™£åˆ—å³ç§»ä¸€æ ¼
 136   2                      
 137   2                      if(grade > 0)
 138   2                      {
 139   3                              if(eaten == 1 && grade != grade_temp)
 140   3                              {
 141   4                                      body_display[tail_start_num] = body_display[tail_start_num] | tail[tail_start_num];  // é€²é£Ÿä¸­ï¼Œå°
             -¾å·´ä¸å‘å‰ç§»å‹•ç›´æ¥è®Šæˆç•¶å‰çš„å°¾å·´
 142   4                                      body_display[head_start_num_temp] = body_display[head_start_num_temp] | head_show_temp[head_start_num_
             -temp]; // ä¸¦å°‡ç§»å‹•å‰çš„é ­åŠ å…¥body_displayä¸­
 143   4                                      Direction_num++;                         // æ¯é€²é£Ÿä¸€æ¬¡å°±è¦æŠŠå°¾å·´è¦ç§»å‹•ç¬¬å¹¾å€‹ä½ç½®çš„æ–¹å‘é™£åˆ—çš„æ•¸å­—å
             -¢åŠ 1
 144   4                              }
 145   3                                      
 146   3                              else if(grade == grade_temp)
 147   3                              {
 148   4                                      tail_temp[tail_start_num] = tail[tail_start_num];    // å„²å­˜å°¾å·´ä¸Šä¸€å€‹ä½ç½®
 149   4                                      tail_start_num_temp = tail_start_num;
 150   4                                      
 151   4                                      tail_move();                            // å°¾å·´ç§»å‹•
 152   4                                      
 153   4                                      body_display[head_start_num_temp] = body_display[head_start_num_temp] | head_show_temp[head_start_num_
             -temp]; // å°‡ç§»å‹•å‰çš„é ­åŠ å…¥body_displayä¸­
 154   4                                      body_display[tail_start_num] =  body_display[tail_start_num] | tail[tail_start_num] ;                                            // å°‡ç§»
             -å‹•å¾Œçš„å°¾å·´åŠ å…¥body_displayä¸­
 155   4                                      body_display[tail_start_num_temp] = body_display[tail_start_num_temp] ^ tail_temp[tail_start_num_temp]
             -;      // æŠŠç§»å‹•å‰çš„å°¾å·´æ¶ˆé™¤
 156   4                              }
 157   3                      }
 158   2      
 159   2                      
 160   2                      if(eaten == 0)
 161   2                              for(i=0;i<8;i++)                  // decition lost !!
 162   2                                      if (head_show[Head_start_num] == (body_display[i] & head_show[Head_start_num]) && Head_start_num == i)
 163   2                                      lost = 1;
 164   2                      
 165   2                      match();
 166   2      
 167   2                      
 168   2                      if(grade >= set_win_grade)
 169   2                              grade = set_win_grade;
C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 4   

 170   2                                              
 171   2                      for(t=0;t<speed;t++)  // speed
 172   2                      {
 173   3                              direction(&Direction_key); //decide direction
 174   3                              scan(x);
 175   3                      }
 176   2                      
 177   2                      seed++;
 178   2              }
 179   1      
 180   1              return 0;       
 181   1              
 182   1      }
 183          
 184          ///////////////////// random /////////////////
 185          
 186          int random(int *seed)
 187          {
 188   1              srand(*seed);
 189   1              return rand();
 190   1      }
 191          
 192          //////////////////////////////////////////////
 193          
 194          ///////////////////// initial ////////////////
 195          
 196          void initial(unsigned char matrix[])
 197          {
 198   1              int i;
 199   1              char temp = 0x00;
 200   1              for(i=0;i<8;i++)
 201   1              {
 202   2                      matrix[i] = temp;
 203   2              }
 204   1      }
 205          
 206          ///////////////////////////////////////////////
 207          
 208          //////////////////// direction ////////////////
 209          
 210          void direction(int *Direction)
 211          {       
 212   1              switch(P3)
 213   1              {
 214   2                      case 0x00:
 215   2                      {
 216   3                              *Direction = *Direction;
 217   3                              break; //default
 218   3                      }
 219   2                      case 0x01:
 220   2                      {
 221   3                              if(*Direction == 1)
 222   3                                      break;
 223   3                              *Direction = 0; // up
 224   3                              break;
 225   3                      }
 226   2                      case 0x02:
 227   2                      {
 228   3                              if(*Direction == 0)
 229   3                                      break;
 230   3                              *Direction = 1; // down
 231   3                              break;
C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 5   

 232   3                      }
 233   2                      case 0x04:
 234   2                      {
 235   3                              if(*Direction == 3)
 236   3                                      break;
 237   3                              *Direction = 2; // left
 238   3                              break;
 239   3                      }
 240   2                      case 0x08:
 241   2                      {
 242   3                              if(*Direction == 2)
 243   3                                      break;
 244   3                              *Direction = 3; // right
 245   3                              break;
 246   3                      }
 247   2                              
 248   2              }
 249   1      }
 250          
 251          ///////////////////////////////////////////////
 252          
 253          //////////////////// move /////////////////////
 254          
 255          void move(int *Head_start_num,int *Direction)
 256          {
 257   1              int i = 0;
 258   1              int temp = 0x00;
 259   1              int Head_start_num_right = (*Head_start_num+1)%8;
 260   1              int Head_start_num_left = (*Head_start_num-1)%8;
 261   1      
 262   1              if (Head_start_num_left == -1)
 263   1                      Head_start_num_left = 7;
 264   1              if (Head_start_num_right == 8)
 265   1                      Head_start_num_right = 0;
 266   1                      
 267   1              if (*Direction == 0)
 268   1              {
 269   2                      head_show[*Head_start_num] = _cror_(head_show[*Head_start_num],1); // move 1 up
 270   2              }
 271   1              
 272   1              if (*Direction == 1)
 273   1              {
 274   2                      head_show[*Head_start_num] = _crol_(head_show[*Head_start_num],1); // move 1 down
 275   2              }
 276   1              
 277   1              if (*Direction == 2)
 278   1              {
 279   2                      head_show[Head_start_num_right] = head_show[*Head_start_num]; // move 1 right
 280   2                      head_show[*Head_start_num] = temp;
 281   2                      *Head_start_num = Head_start_num_right;
 282   2              }
 283   1              
 284   1              if (*Direction == 3)
 285   1              {
 286   2                      head_show[Head_start_num_left] = head_show[*Head_start_num]; //move 1 left
 287   2                      head_show[*Head_start_num] = temp;
 288   2                      *Head_start_num = Head_start_num_left;
 289   2              }
 290   1              
 291   1              if (food_start == head_show[*Head_start_num] && food_num == *Head_start_num )
 292   1              {
 293   2                      grade = grade + 1;
C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 6   

 294   2                      eaten = 1;
 295   2                      speed--;
 296   2                      if(speed < 5)
 297   2                              speed = 5;
 298   2              }
 299   1      }
 300          
 301          ///////////////////////////////////////////////
 302          
 303          //////////////////// food /////////////////////
 304          
 305          void food(void)
 306          {
 307   1              initial(food_show);
 308   1              seed++;
 309   1              food_start = start_seat[random(&seed)%8];
 310   1              seed++;
 311   1              food_num = random(&seed)%8;
 312   1      }
 313          
 314          ///////////////////////////////////////////////
 315          
 316          //////////////////// food_check ///////////////
 317          
 318          void food_check(int *Head_start_num)
 319          {
 320   1              if (food_start == head_show[*Head_start_num] && food_num == *Head_start_num ) // åˆ¤æ–·é£Ÿç‰©æ˜¯å¦èˆ‡é ­
             -é‡ç–Š
 321   1              {
 322   2                      food();
 323   2                      food_check(Head_start_num);
 324   2              }
 325   1              else
 326   1                      food_show[food_num] = food_start;
 327   1                      
 328   1      }
 329          
 330          ///////////////////////////////////////////////
 331          
 332          //////////////////// match ////////////////////
 333          
 334          void match(void)
 335          {
 336   1              int i;
 337   1              for(i=0;i<8;i++)
 338   1              {
 339   2                      display[i] = food_show[i] | head_show[i] | body_display[i] ;
 340   2              }
 341   1      
 342   1      }
 343          
 344          ///////////////////////////////////////////////
 345          
 346          ///////////////////// scan ////////////////////
 347          
 348          void scan(unsigned char k)
 349          {
 350   1              unsigned char m;
 351   1              unsigned char com;
 352   1              com = 0xfe;
 353   1              for(m=0;m<8;m++)
 354   1              {
C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 7   

 355   2                      if (grade >= set_win_grade)
 356   2                              P1 = win[k];
 357   2                      else if (lost == 1)
 358   2                              P1 = defeat[k];
 359   2                      else if (start == 0)
 360   2                              P1 = go[k];
 361   2                      else
 362   2                              P1 = display[k];
 363   2                      P2 = com;
 364   2                      delayms(2);
 365   2                      P2 = 0xff;
 366   2                      com = _crol_(com,1);
 367   2                      k++;
 368   2              }
 369   1      }
 370          
 371          ////////////////////////////////////////////////
 372          
 373          ///////////////////// delayms //////////////////
 374          
 375          void delayms(unsigned int time)
 376          {
 377   1              unsigned int n;
 378   1              while(time>0)
 379   1              {
 380   2                      n=120;
 381   2                      while(n>0) n--;
 382   2                      time--;
 383   2              }
 384   1      }
 385          
 386          /////////////////////////////////////////////////
 387          
 388          //////////// Direction_matrix_right ////////////////
 389          
 390          void Direction_matrix_right(void)
 391          {
 392   1              int i;
 393   1      
 394   1              for(i=63;i>0;i--)
 395   1              {
 396   2                      Direction_matrix[i] = Direction_matrix[i-1];
 397   2              }
 398   1      }
 399          
 400          /////////////////////////////////////////////////
 401          
 402          ////////////////// tail_move /////////////////////////
 403          
 404          void tail_move(void)
 405          {
 406   1              int i = 0;
 407   1              int temp = 0x00;
 408   1              int tail_start_num_right = (tail_start_num+1)%8;
 409   1              int tail_start_num_left = (tail_start_num-1)%8;
 410   1      
 411   1              if (tail_start_num_left == -1)
 412   1                      tail_start_num_left = 7;
 413   1              if (tail_start_num_right == 8)
 414   1                      tail_start_num_right = 0;
 415   1                      
 416   1              if (Direction_matrix[Direction_num] == 0)
C51 COMPILER V8.18   SNAKE_9                                                               07/06/2017 17:03:19 PAGE 8   

 417   1              {
 418   2                      tail[tail_start_num] = _cror_(tail[tail_start_num],1); // move 1 up
 419   2              }
 420   1              
 421   1              if (Direction_matrix[Direction_num] == 1)
 422   1              {
 423   2                      tail[tail_start_num] = _crol_(tail[tail_start_num],1); // move 1 down
 424   2              }
 425   1              
 426   1              if (Direction_matrix[Direction_num] == 2)
 427   1              {
 428   2                      tail[tail_start_num_right] = tail[tail_start_num]; // move 1 right
 429   2                      tail[tail_start_num] = temp;
 430   2                      tail_start_num = tail_start_num_right;
 431   2              }
 432   1              
 433   1              if (Direction_matrix[Direction_num] == 3)
 434   1              {
 435   2                      tail[tail_start_num_left] = tail[tail_start_num]; //move 1 left
 436   2                      tail[tail_start_num] = temp;
 437   2                      tail_start_num = tail_start_num_left;
 438   2              }
 439   1              
 440   1      }
 441          
 442          /////////////////////////////////////////////////////
 443          
 444          
 445          
 446          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1502    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     85      31
   IDATA SIZE       =     88    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
